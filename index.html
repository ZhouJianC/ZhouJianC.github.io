<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="每天学习一点点">
<meta property="og:type" content="website">
<meta property="og:title" content="Striver">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Striver">
<meta property="og:description" content="每天学习一点点">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Striver">
<meta name="twitter:description" content="每天学习一点点">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Striver</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Striver</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">To seek, to find, and not to yield</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/18/LeetcodeTop100/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JCZhou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Striver">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/18/LeetcodeTop100/" itemprop="url">LeetcodeTop100</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-18T10:26:18+08:00">
                2020-07-18
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-09-18T10:28:43+08:00">
                2020-09-18
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/15/Offer-Code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JCZhou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Striver">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/15/Offer-Code/" itemprop="url">剑指Offer题解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-15T00:20:03+08:00">
                2020-07-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-09-20T17:00:58+08:00">
                2020-09-20
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Offer-03-数组中的重复数字"><a href="#Offer-03-数组中的重复数字" class="headerlink" title="Offer 03 数组中的重复数字"></a>Offer 03 数组中的重复数字</h2><hr>
<p>找出长度为n的数组中任意一个重复的数字，数组中所有数字都在(0 ~ n - 1)的范围内</p>
<blockquote>
<p>思路可以选择<figure class="highlight plain"><figcaption><span>为保证O(1)的空间复杂度，我们对原数组进行操作。如果无重复，那么```nums[i] </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">public int findRepeatNumber(int[] nums) &#123;</span><br><span class="line">        int temp;</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            while(nums[i] != i) &#123;</span><br><span class="line">                if(nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">                    return nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                temp = nums[i];</span><br><span class="line">                nums[i] = nums[temp];</span><br><span class="line">                nums[temp] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="Offer-04-二维数组中的查找"><a href="#Offer-04-二维数组中的查找" class="headerlink" title="Offer 04 二维数组中的查找"></a>Offer 04 二维数组中的查找</h2><hr>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<blockquote>
<p>数组的右上角元素为关键值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span> || matrix == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, col = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row &lt; matrix.length &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col] &gt; target) &#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col] &lt; target) &#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Offer-05-替换字符串中的空格"><a href="#Offer-05-替换字符串中的空格" class="headerlink" title="Offer 05 替换字符串中的空格"></a>Offer 05 替换字符串中的空格</h2><hr>
<p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">' '</span>) &#123;</span><br><span class="line">                res.append(<span class="string">"%20"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Offer-06-从尾到头打印链表（链表反转，打印输出）"><a href="#Offer-06-从尾到头打印链表（链表反转，打印输出）" class="headerlink" title="Offer 06 从尾到头打印链表（链表反转，打印输出）"></a>Offer 06 从尾到头打印链表（链表反转，打印输出）</h2><hr>
<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 反转链表， 并统计长度</span></span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>, node = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = head.next;</span><br><span class="line">            head.next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = node;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历输出</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            res[i] = newHead.val;</span><br><span class="line">            newHead = newHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Offer-07-重建二叉树"><a href="#Offer-07-重建二叉树" class="headerlink" title="Offer 07 重建二叉树"></a>Offer 07 重建二叉树</h2><hr>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字</p>
<blockquote>
<p>例如先序遍历：3 9 20 15 7 中序遍历：9 3 15 20 7， 那么可以判断第一个根节点为3，根据中序判断其左子树为9，右子树为3 15 20 7序列。其左右子树可以用同样的方法<br>判断，所以使用递归来实现，时间空间复杂度都为O(n)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] pre;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = preorder.length;</span><br><span class="line">        pre = preorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recourTree(<span class="number">0</span>, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//参数：根节点， 在中序序列中包含根节点的序列的左起始点索引， ...右边结束点索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">recourTree</span><span class="params">(<span class="keyword">int</span> rootIndex, <span class="keyword">int</span> leftIndex, <span class="keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftIndex &gt; rightIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = map.get(pre[rootIndex]);</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(pre[rootIndex]);</span><br><span class="line">        node.left = recourTree(rootIndex + <span class="number">1</span>, leftIndex, tmp - <span class="number">1</span>);</span><br><span class="line">        node.right = recourTree(rootIndex + tmp - leftIndex + <span class="number">1</span>, tmp + <span class="number">1</span>, rightIndex);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Offer-09-用两个栈实现队列"><a href="#Offer-09-用两个栈实现队列" class="headerlink" title="Offer 09 用两个栈实现队列"></a>Offer 09 用两个栈实现队列</h2><hr>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )  </p>
<blockquote>
<p>定义两个栈<figure class="highlight plain"><figcaption><span>和```stackOut```,一个负责队列的插入，一个负责队列的删除，关键是删除的时候判断```stackOut```内是否有元素，若有则删除栈顶元素，否者判断```stackIn```是否有元素，若有 将In中数据转移到Out中并删除栈顶，否则返回-1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">// 使用Deque来定义栈，替代Stack比较好，再用LinkedList实现</span><br><span class="line">Deque&lt;Integer&gt; stackIn, stackOut;</span><br><span class="line">    public CQueue() &#123;</span><br><span class="line">        stackIn = new LinkedList&lt;&gt;();</span><br><span class="line">        stackOut = new LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    public void appendTail(int value) &#123;</span><br><span class="line">        stackIn.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    public int deleteHead() &#123;</span><br><span class="line">        if(stackOut.isEmpty()) &#123;</span><br><span class="line">            if(stackIn.isEmpty()) &#123;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                while(!stackIn.isEmpty()) &#123;</span><br><span class="line">                    stackOut.push(stackIn.pop());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stackOut.pop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="Offer-10-I-斐波拉契数列-10-II-青蛙跳台阶的问题"><a href="#Offer-10-I-斐波拉契数列-10-II-青蛙跳台阶的问题" class="headerlink" title="Offer 10-I 斐波拉契数列 10-II 青蛙跳台阶的问题"></a>Offer 10-I 斐波拉契数列 10-II 青蛙跳台阶的问题</h2><hr>
<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(<span class="number">0</span>) = <span class="number">0</span>,   F(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">F(N) = F(N - <span class="number">1</span>) + F(N - <span class="number">2</span>), 其中 N &gt; <span class="number">1</span>.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>迭代</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Offer-11-旋转数组的最小数字"><a href="#Offer-11-旋转数组的最小数字" class="headerlink" title="Offer 11 旋转数组的最小数字"></a>Offer 11 旋转数组的最小数字</h2><hr>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p>
<blockquote>
<p>对于旋转后的数组，左边 [3,4,5], 右边 [1,2], 实际查找的是右边的第一个元素，根据左边数&gt;=右边数的性质，我们可以通过二分查找来实现, 二分法比较的时候，以最右边的元素为边界</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid] &gt; numbers[high]) &#123;</span><br><span class="line">                <span class="comment">// mid在左边</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &lt; numbers[high]) &#123;</span><br><span class="line">                <span class="comment">// mid在右边</span></span><br><span class="line">                high = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// mid在右边界</span></span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// low == high</span></span><br><span class="line">        <span class="keyword">return</span> numbers[low];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Offer-12-矩阵中的路径"><a href="#Offer-12-矩阵中的路径" class="headerlink" title="Offer 12 矩阵中的路径"></a>Offer 12 矩阵中的路径</h2><hr>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）<br>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<blockquote>
<p>使用深度优先搜索的方法，DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。剪枝：在搜索中，遇到这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为可行性剪枝。在遍历的过程中，标记已经访问过的点，但是结束访问后，需要复原</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] cha = word.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(board, cha, i, j, <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] cha, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 剪枝</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] != cha[k]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k == cha.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> res;</span><br><span class="line">    <span class="keyword">char</span> tmp = board[i][j];</span><br><span class="line">    <span class="comment">// 标记</span></span><br><span class="line">    board[i][j] = <span class="string">'/'</span>;</span><br><span class="line">    res = dfs(board, cha, i - <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(board, cha, i + <span class="number">1</span>, j, k + <span class="number">1</span>) ||</span><br><span class="line">            dfs(board, cha, i, j - <span class="number">1</span>, k + <span class="number">1</span>) || dfs(board, cha, i, j + <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 去除标记</span></span><br><span class="line">    board[i][j] = tmp;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Offer-13-机器人的运动范围"><a href="#Offer-13-机器人的运动范围" class="headerlink" title="Offer 13 机器人的运动范围"></a>Offer 13 机器人的运动范围</h2><hr>
<p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0,0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35,37] ，因为3+5+3+7=18。但它不能进入方格 [35,38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<blockquote>
<p>深度优先搜索（DFS)，采用递归的方法，先对搜索方向进行优化，根据试根解的的特点，只需要向下向右运动即可。然后递归终止的条件是机器人到达边界、和大于给定值、当前位置已经访问过。否则执行加一，再向右、向下递归，当前位置设置已访问; 广度优先搜索（BFS）, 不同于DFS的一个方向搜索到底再回退，它采用平推的方式。采用队列以迭代的方式。时间空间复杂度都是O(m)(n)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深度优先搜索、递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> sumi, <span class="keyword">int</span> sumj, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span>[][] isSearch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n || sumi + sumj &gt; k || isSearch[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        isSearch[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, (i + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? sumi + <span class="number">1</span> : sumi - <span class="number">8</span>, sumj, m, n, k, isSearch)</span><br><span class="line">                + dfs(i, j + <span class="number">1</span>, sumi, (j + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? sumj + <span class="number">1</span> : sumj - <span class="number">8</span>, m, n, k, isSearch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广度优先搜索、队列、迭代</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] isSearch = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> i = temp[<span class="number">0</span>], j = temp[<span class="number">1</span>], si = temp[<span class="number">2</span>], sj = temp[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= m || j &gt;= n || si + sj &gt; k || isSearch[i][j]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            isSearch[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            res++;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i + <span class="number">1</span>, j, (i + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? si + <span class="number">1</span> : si - <span class="number">8</span>, sj&#125;);</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j + <span class="number">1</span>, si, (j + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? sj + <span class="number">1</span> : sj - <span class="number">8</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Offer-14-I-剪绳子"><a href="#Offer-14-I-剪绳子" class="headerlink" title="Offer 14-I 剪绳子"></a>Offer 14-I 剪绳子</h2><hr>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18</p>
<blockquote>
<p>经过推论，全部剪成长度为3的段，乘积会最大，因此均匀的分为3，不足的以2或者4来代替</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = n / <span class="number">3</span>, b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a - <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a) * <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Offer-14-II-剪绳子II"><a href="#Offer-14-II-剪绳子II" class="headerlink" title="Offer 14-II 剪绳子II"></a>Offer 14-II 剪绳子II</h2><hr>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1</p>
<blockquote>
<p>经过推论，全部剪成长度为3的段，乘积会最大，因此均匀的分为3，不足的以2或者4来代替</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mod = (<span class="keyword">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">4</span>) &#123;</span><br><span class="line">        res *= <span class="number">3</span>;</span><br><span class="line">        res %= mod;</span><br><span class="line">        n -= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(res * n % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Offer-15-二进制中1的个数"><a href="#Offer-15-二进制中1的个数" class="headerlink" title="Offer 15 二进制中1的个数"></a>Offer 15 二进制中1的个数</h2><hr>
<p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2</p>
<blockquote>
<p>两种思路：1）位运算n &amp; 1 = 1表示最后一位为1，否则为0 ；2）n &amp; (n -1) 将二进制的最右边一个1变为0，这个复杂度最小O(M), M为1的个数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// n &amp; 1位运算</span></span><br><span class="line">       <span class="comment">/*while(n != 0) &#123;</span></span><br><span class="line"><span class="comment">           res += n &amp; 1;</span></span><br><span class="line"><span class="comment">           n &gt;&gt;&gt;= 1;</span></span><br><span class="line"><span class="comment">       &#125;*/</span></span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Offer-16-数值的整数次方"><a href="#Offer-16-数值的整数次方" class="headerlink" title="Offer 16 数值的整数次方"></a>Offer 16 数值的整数次方</h2><hr>
<p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">if</span>(N &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            N = -N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(N &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// N的二进制最后一位为1</span></span><br><span class="line">                res *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最后一位为0时，结果不变，但是x累乘 为下一个1做准备</span></span><br><span class="line">            x *= x;</span><br><span class="line">            <span class="comment">// N /= 2;</span></span><br><span class="line">            N = N &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Offer-25-合并两个排序的列表"><a href="#Offer-25-合并两个排序的列表" class="headerlink" title="Offer 25 合并两个排序的列表"></a>Offer 25 合并两个排序的列表</h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode now = head;;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class="line">                now.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                now.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            now = now.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            now.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            now.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Offer-26-树的子结构"><a href="#Offer-26-树的子结构" class="headerlink" title="Offer 26 树的子结构"></a>Offer 26 树的子结构</h2><hr>
<p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)<br>B是A的子结构， 即 A中有出现和B相同的结构和节点值。例如: 给定的树 A:<br>     3<br>    / \<br>   4   5<br>  / \<br> 1   2<br>给定的树 B：<br>   4<br>  /<br> 1<br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。输入：A = [3,4,5,1,2], B = [4,1]，输出：true  </p>
<blockquote>
<p>从主树的第一个节点开始，每次与子树的第一个节点比较，若相等，则主子树同步比较左右子树，这个过程肯定是递归（深度优先搜索的），只要有一个不满足就返回false。那么再从主树的下一个节点开始，依次与子树的第一个节点开始同样的比较过程，所以还是递归。  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (A == <span class="keyword">null</span> || B == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从主树当前节点，以及递归从主树当前节点的左右子节点，开始与子树递归比较</span></span><br><span class="line">    <span class="keyword">return</span> dfs(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定根节点之后进行递归比较</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (B == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (A.val == B.val) &amp;&amp; dfs(A.left, B.left) &amp;&amp; dfs(A.right, B.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Offer-27-二叉树的镜像"><a href="#Offer-27-二叉树的镜像" class="headerlink" title="Offer 27 二叉树的镜像"></a>Offer 27 二叉树的镜像</h2><hr>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1]<br>例如输入：<br>     4<br>   /   \<br>  2     7<br> / \   / \<br>1   3 6   9<br>镜像输出：<br>     4<br>   /   \<br>  7     2<br> / \   / \<br>9   6 3   1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mirror</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 深度优先搜索，递归操作</span></span><br><span class="line">        TreeNode tmp = node.left;</span><br><span class="line">        node.left = node.right;</span><br><span class="line">        node.right = tmp;</span><br><span class="line">        mirror(node.left);</span><br><span class="line">        mirror(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        mirror(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Offer-28-对称的二叉树"><a href="#Offer-28-对称的二叉树" class="headerlink" title="Offer 28 对称的二叉树"></a>Offer 28 对称的二叉树</h2><hr>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。示例：输入：root = [1,2,2,3,4,4,3] 输出：true  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recur(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode l, TreeNode r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span> &amp;&amp; r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span> || r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l.val != r.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recur(l.left, r.right) &amp;&amp; recur(l.right, r.left);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Offer-48-最长不含重复字符的子字符串的长度"><a href="#Offer-48-最长不含重复字符的子字符串的长度" class="headerlink" title="Offer 48 最长不含重复字符的子字符串的长度"></a>Offer 48 最长不含重复字符的子字符串的长度</h2><hr>
<p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度</p>
<blockquote>
<p>通过滑动窗口和双指针的方法, 当前窗口为[l, r)<br>标准字符的ASCII码的十进制范围在0 ~ 127之间，所以可以不用Map 或者 Set，直接使用int数组来映射。注：小写字符a - z的ascii码十进制为 97-122；大写字符A - Z的ascii码十进制为 65 - 90；0 - 9 ascii码的十进制范围为 48 - 57</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenghtOfLongestSubString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; s.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; s.length() &amp;&amp; map[s.charAt(r)] == <span class="number">0</span>) &#123;</span><br><span class="line">            map[s.charAt(r++)]++;</span><br><span class="line">            res = Math.max(res, r - l);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            map[s.charAt(l++)]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Offer-68-I-二叉搜索树的最近公共祖先"><a href="#Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="Offer 68-I 二叉搜索树的最近公共祖先"></a>Offer 68-I 二叉搜索树的最近公共祖先</h2><hr>
<p>给定一个二叉搜索树，找到该树中两个指定节点的最近公共祖先</p>
<blockquote>
<p>根据二叉搜索树的性质：对于任意一棵子树，左子树 &lt; 根节点 &lt; 右子树， 因此根据判断p、q与根结点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">来讨论，默认p &lt; q: (1)当p &lt; q &lt; root, 去root左子树寻找 (2)当root &lt; p &lt; q, 去root右子树寻找 (3) 当p &lt;= root &lt;= q, root即是结果  </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public TreeNode lowestCommon(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">    // 保证p &lt; q</span><br><span class="line">    if(p.val &lt; q.val) &#123;</span><br><span class="line">        TreeNode tmp = p;</span><br><span class="line">        p = q;</span><br><span class="line">        q = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    while(root != null) &#123;</span><br><span class="line">        if(root.val &gt; q.val) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;else if(root.val &lt; q.val) &#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="Offer-68-II-二叉树的最近公共祖先"><a href="#Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="Offer 68-II 二叉树的最近公共祖先"></a>Offer 68-II 二叉树的最近公共祖先</h2><hr>
<p>给定一个二叉树, 找到该树中两个指定节点p、q的最近公共祖先</p>
<blockquote>
<p>递归对二叉树进行后序遍历, 遍历每一棵子树，判断公共祖先</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommon</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q) &#123;</span><br><span class="line">        <span class="comment">// 递归终止的条件</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    TreeNode left = lowestCommon(root.left, p, q);</span><br><span class="line">    TreeNode right = lowest(root.right, p, q);</span><br><span class="line">    <span class="comment">// 包括了 left == null &amp;&amp; right == null</span></span><br><span class="line">    <span class="keyword">if</span>(left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左右子树都不为空</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/Internet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JCZhou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Striver">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/20/Internet/" itemprop="url">TCP/IP协议和OSI模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-20T21:23:59+08:00">
                2020-04-20
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-09-18T10:24:39+08:00">
                2020-09-18
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p> <img src="/images/Internet_01.png" alt="计算机网络体系结构对比"></p>
<blockquote>
<ul>
<li>TCP/IP四层的体系结构，主要包括：应用层、运输层、网际层和网络接口层</li>
<li>五层协议的体系结构：应用层、运输层、网络层、数据链路层和物理层</li>
<li>OSI七层协议模型：应用层、表现层、会话层、运输层、网络层、数据链路层、物理层</li>
</ul>
</blockquote>
<h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><p> <img src="/images/Internet_02.png" alt="各层涉及到的协议"></p>
<blockquote>
<p>在互联网使用的各种协议中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的 TCP/IP 并不一定是单指 TCP 和 IP 这两个具体的协议，而往往是表示互联网所使用的整个 TCP/IP 协议族。TCP（传输控制协议）和IP（网际协议） 是最先定义的两个核心协议，所以才统称为TCP/IP协议族</p>
</blockquote>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><blockquote>
<p>应用层( application-layer ）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。  </p>
</blockquote>
<h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><blockquote>
<p>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。主要有两种协议：</p>
</blockquote>
<ul>
<li>TCP（传输控制协议）：提供面向连接的，可靠的数据传输服务</li>
<li><p>UDP（用户数据协议）：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）</p>
<p><img src="/images/Internet_03.png" alt="TCP和UDP对比"></p>
</li>
</ul>
<p>每一个应用层（TCP/IP参考模型的最高层）协议一般都会使用到两个传输层协议之一：</p>
<blockquote>
<p>运行在TCP协议上的协议：</p>
<ul>
<li>HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。</li>
<li>HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。</li>
<li>FTP（File Transfer Protocol，文件传输协议），用于文件传输。</li>
<li>POP3（Post Office Protocol, version 3，邮局协议），收邮件用。</li>
<li>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。</li>
<li>TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。</li>
<li>SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用  </li>
</ul>
<p>运行在UDP协议上的协议：</p>
<ul>
<li>BOOTP（Boot Protocol，启动协议），应用于无盘设备。</li>
<li>NTP（Network Time Protocol，网络时间协议），用于网络同步。</li>
<li>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</li>
</ul>
<p>运行在TCP和UDP协议上：</p>
<ul>
<li>DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。  </li>
</ul>
</blockquote>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><blockquote>
<p>网络层的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议，因此分组也叫 IP 数据报 ，简称数据报</strong>。<br>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或IP层  </p>
</blockquote>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><blockquote>
<p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</p>
<p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束  </p>
</blockquote>
<p>Web应用的通信传输流如下：</p>
<p> <img src="/images/Internet_04.png" alt="通信传输流"></p>
<blockquote>
<p>发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除  </p>
</blockquote>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><blockquote>
<p>在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的  </p>
</blockquote>
<p>博客参考链接：<br>1.<a href="https://blog.csdn.net/ThinkWon/article/details/104903925" target="_blank" rel="noopener">TCP/IP</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/18/Http/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JCZhou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Striver">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/18/Http/" itemprop="url">Http协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-18T19:43:21+08:00">
                2020-04-18
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-09-17T16:33:54+08:00">
                2020-09-17
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/16/TCP-IP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JCZhou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Striver">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/16/TCP-IP/" itemprop="url">TCP三次握手四次挥手</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-16T19:23:12+08:00">
                2020-04-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-09-20T18:51:49+08:00">
                2020-09-20
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><ul>
<li>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。在发送数据前，通讯双方必须在彼此间建立一条<br>连接。所谓的“连接”，其实就是客服端和服务端保存的一份关于对方的信息、比如ip地址、端口号等。  </li>
<li>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。  </li>
<li>一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：连接、数据传输、退出（关闭）。<strong>通过三次握手建立一个链接, 通过四次挥手来关闭一个连接。当一个连接被建立或者被终止时，交换的报文段只包含TCP头部，而没有数据。</strong>  </li>
</ul>
<h2 id="TCP报文头部"><a href="#TCP报文头部" class="headerlink" title="TCP报文头部"></a>TCP报文头部</h2><p> <img src="/images/TCP-IP_01.png" alt="TCP Header"></p>
<blockquote>
<ul>
<li>序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记</li>
<li>确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1</li>
<li>标志位：共6个，URG, ACK, PSH, RST, SYN, FIN等</li>
</ul>
<blockquote>
<ul>
<li>ACK : 确认序号有效</li>
<li>FIN : 释放一个连接</li>
<li>SYN : 发起一个连接</li>
<li>RST : 重置连接</li>
<li>URG : 紧急指针有效</li>
<li>PSH : 接收方应该尽快将报文交给应用层  </li>
</ul>
</blockquote>
</blockquote>
<p>其中确认方ack = 发起方的seq + 1, 两端匹配</p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>三次握手的本质是确认通信双方收发数据的能力</p>
<p><img src="/images/TCP-IP_02.png" alt="TCP三次握手"></p>
<blockquote>
<ul>
<li>第一次握手：<strong>Server确认了 对方发送正常，自己接收正常</strong></li>
</ul>
<blockquote>
<ul>
<li>在第一次握手中，客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100（图中的x）</li>
</ul>
</blockquote>
<ul>
<li>第二次握手：<strong>Client确认了 自己发送、接收正常，对方发送、接收正常</strong>；Server确认了 对方发送正常，自己接收正常</li>
</ul>
<blockquote>
<ul>
<li>在第二次握手中，服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。</li>
</ul>
</blockquote>
<ul>
<li>第三次握手：Client确认了 自己发送、接收正常，对方发送、接收正常；Server确认了 <strong>自己发送</strong>、接收正常，对方发送、<strong>对方接收正常</strong></li>
</ul>
<blockquote>
<ul>
<li>在第三次握手中，客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接</li>
</ul>
</blockquote>
</blockquote>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><blockquote>
<p>四次挥手的目的是关闭一个连接(注意图中状态的变化)</p>
</blockquote>
<p><img src="/images/TCP-IP_03.png" alt="TCP四次挥手"></p>
<p>比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据  </p>
<blockquote>
<ul>
<li>第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号  </li>
<li>第二次挥手：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完</li>
<li>第三次握手：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)</li>
<li>第四次挥手：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些</li>
</ul>
</blockquote>
<h2 id="TIME-WAIT-和-CLOSE-WAIT"><a href="#TIME-WAIT-和-CLOSE-WAIT" class="headerlink" title="TIME_WAIT 和 CLOSE_WAIT"></a>TIME_WAIT 和 CLOSE_WAIT</h2><p>由于socket是全双工的工作模式，一个socket的关闭，是需要四次握手来完成的。从图中可以看到客户端和服务端在四次挥手中的状态变化。主动关闭的一方，调用close()；协议层发送FIN包，状态变为<strong>FIN_WAIT_1</strong>;被动关闭的一方收到FIN包后，协议层回复ACK，然后进入<strong>CLOSE_WAIT</strong>状态；主动关闭的一方收到后，进入<strong>FIN_WAIT_2</strong>状态。被动关闭的一方在数据传输完成后，调用close()操作，然后协议层发送FIN包给主动关闭的一方，等待对方的ACK，进入<strong>LAST_ACK</strong>状态。主动关闭的一方收到FIN包后，协议层回复ACK，然后进入<strong>TIME_WAIT</strong>。被动关闭的一方收到后，进入CLOSE状态。等待2MSL。主动关闭的一方，<strong>结束TIME_WAIT</strong>，进入CLOSE状态。  </p>
<blockquote>
<ul>
<li>主动关闭连接的一方 – 也就是主动调用socket的close操作的一方，最终会进入TIME_WAIT状态 ;</li>
<li>被动关闭连接的一方，有一个中间状态，即CLOSE_WAIT，因为协议层在等待上层的应用程序，主动调用close操作后才主动关闭这条连接 </li>
<li>TIME_WAIT会默认等待2MSL时间后，才最终进入CLOSED状态；</li>
<li>在一个连接没有进入CLOSED状态之前，这个连接是不能被重用的  </li>
</ul>
</blockquote>
<p>socket其实就是一个五元组，例如：[110.122.144.166:43678, tcp, 110.88.92.104:80] 包括：<strong>源IP, 源端口, 目的IP, 目的端口, 类型(TCP or UDP)</strong>. 这个五元组，即标识了一条可用的连接。而<strong>TIME_WAIT</strong>的作用是为了防止前一个连接上的延迟的数据包或者丢失重传的数据包，被后面复用的连接错误的接收；同时也确保连接方在时间范围内，关闭自己的连接。因为TIME_WAIT状态下，该socket所占有的本地端口号是一直不释放的。  </p>
<h2 id="为啥TCP连接时候是3次？2次不行吗"><a href="#为啥TCP连接时候是3次？2次不行吗" class="headerlink" title="为啥TCP连接时候是3次？2次不行吗"></a>为啥TCP连接时候是3次？2次不行吗</h2><blockquote>
<p>因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。</p>
<p>如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。所以三次握手就能确认双发收发功能都正常，缺一不可。  </p>
</blockquote>
<h2 id="为什么TCP连接的时候是3次，关闭的时候却是4次"><a href="#为什么TCP连接的时候是3次，关闭的时候却是4次" class="headerlink" title="为什么TCP连接的时候是3次，关闭的时候却是4次"></a>为什么TCP连接的时候是3次，关闭的时候却是4次</h2><blockquote>
<p>因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)  </p>
</blockquote>
<h2 id="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接"><a href="#为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接" class="headerlink" title="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接"></a>为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接</h2><blockquote>
<p>同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了  </p>
</blockquote>
<h2 id="如果已经建立了连接，但是客户端突然出现故障了怎么办"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办</h2><blockquote>
<p>TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接  </p>
</blockquote>
<p>博客参考链接：<br>1.<a href="https://blog.csdn.net/ThinkWon/article/details/104903925" target="_blank" rel="noopener">TCP/IP</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/20/Design-Patterns/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JCZhou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Striver">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/20/Design-Patterns/" itemprop="url">设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-20T18:59:15+08:00">
                2019-09-20
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-09-21T16:18:03+08:00">
                2020-09-21
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Design-Pattern/" itemprop="url" rel="index">
                    <span itemprop="name">Design Pattern</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote>
<p>单例设计模式就是采取一定的方法保证在整个的软件系统中，对于某个类只能存在一个对象实例 ，并且该类只提供一个得到其对象实例的方法。<br>优点：</p>
<ul>
<li>某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销</li>
<li>省去了new操作符，降低了系统内存的使用频率，减轻GC压力</li>
<li>有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程.  </li>
</ul>
</blockquote>
<p>实现方式：  </p>
<ul>
<li>懒汉式(线程安全)  </li>
</ul>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span> </span>{  
    <span class="comment">// 定义静态类变量</span>
    <span class="keyword">private</span> <span class="keyword">static</span> SingleObject singleObject;

    <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span> </span>{}

    <span class="comment">// 原本是线程不安全的，所以加同步锁 synchronized</span>
    <span class="comment">// 第一次调用时才初始化</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingleObject <span class="title">getInstance</span><span class="params">()</span> </span>{
        <span class="keyword">if</span> (singleObject == <span class="keyword">null</span>) {
            singleObject = <span class="keyword">new</span> SingleObject();
        }
        <span class="keyword">return</span> singleObject;
    }
}
</code></pre>
<ul>
<li>饿汉式(线程安全)  </li>
</ul>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span> </span>{

    <span class="keyword">private</span> <span class="keyword">static</span> SingleObject singleObject = <span class="keyword">new</span> SingleObject();

    <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span> </span>{}

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> singleObject;
    }
}  
</code></pre>
<blockquote>
<p>懒汉式与饿汉式的区别  </p>
<ul>
<li>饿汉式就是类一旦加载，就会把单例初始化完成，保证<code>getInstance()</code>的时候，单例已经创建好了。  </li>
<li>懒汉式比较懒，只有在调用<code>getInstance()</code>才初始化这个单例。所以饿汉式是天生线程安全的，懒汉式后期加<code>synchronized</code>同步锁保证线程安全  </li>
</ul>
</blockquote>
<ul>
<li>双重校验锁（线程安全）</li>
</ul>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span> </span>{

    <span class="comment">// 双重校验锁</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingleObject singleObject = <span class="keyword">null</span>;

    <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span> </span>{}

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span> </span>{
        <span class="comment">// 第一次校验singleObject是否为空</span>
        <span class="keyword">if</span> (singleObject == <span class="keyword">null</span>) {
            <span class="keyword">synchronized</span>(SingleObject.class) {
                <span class="comment">// 第二次校验singleObject是否为空</span>
                <span class="keyword">if</span> (singleObject == <span class="keyword">null</span>) {
                    singleObject = <span class="keyword">new</span> SingleObject();
                }
            }
        }
        <span class="keyword">return</span> singleObject;

    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {
            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
                <span class="meta">@Override</span>
                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + SingleObject.getInstance().hashCode());
                }
            }).start();
        }
    }
}
</code></pre>
<blockquote>
<p>为什么是双重校验锁实现单例模式呢？</p>
<ul>
<li><p>第一次校验：也就是第一个if（singleton==null），这个是为了代码提高代码执行效率，由于单例模式只要一次创建实例即可，所以当创建了一个实例之后，再次调用getInstance方法就不必要进入同步代码块，不用竞争锁。直接返回前面创建的实例即可。</p>
</li>
<li><p>第二次校验：也就是第二个if（singleton==null），这个校验是防止二次创建实例，假如有一种情况，当singleton还未被创建时，线程t1调用getInstance方法，由于第一次判断singleton==null，此时线程t1准备继续执行，但是由于资源被线程t2抢占了，此时t2页调用getInstance方法，同样的，由于singleton并没有实例化，t2同样可以通过第一个if，然后继续往下执行，同步代码块，第二个if也通过，然后t2线程创建了一个实例singleton。此时t2线程完成任务，资源又回到t1线程，t1此时也进入同步代码块，如果没有这个第二个if，那么，t1就也会创建一个singleton实例，那么，就会出现创建多个实例的情况，但是加上第二个if，就可以完全避免这个多线程导致多次创建实例的问题。</p>
</li>
</ul>
<p>所以说：两次校验都必不可少。  </p>
</blockquote>
<p><strong>volatile</strong>关键词的作用<br>1、可以防止jvm指令重排优化  </p>
<blockquote>
<p>因为 singleton = new Singleton() 这句话可以分为三步：</p>
</blockquote>
<ol>
<li>为 singleton 分配内存空间；</li>
<li>初始化 singleton；</li>
<li>将 singleton 指向分配的内存空间。<br>但是由于JVM具有指令重排的特性，执行顺序有可能变成 1-3-2。 指令重排在单线程下不会出现问题，但是在多线程下会导致一个线程获得一个未初始化的实例。例如：线程T1执行了1和3，此时T2调用 getInstance() 后发现 singleton 不为空，因此返回 singleton， 但是此时的 singleton 还没有被初始化。使用 volatile 会禁止JVM指令重排，从而保证在多线程下也能正常执行  </li>
</ol>
<p>2、保证变量在多线程运行时的可见性  </p>
<blockquote>
<p>在 JDK1.2 之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而在当前 的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就 可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数 据的不一致。 要解决这个问题，就需要把变量声明为 volatile，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行 读取</p>
</blockquote>
<hr>
<h2 id="工厂模式-简单工厂模式"><a href="#工厂模式-简单工厂模式" class="headerlink" title="工厂模式-简单工厂模式"></a>工厂模式-简单工厂模式</h2><blockquote>
<p>简单工厂模式（Simple Factory Pattern）属于类的创建型模式，又叫静态工厂方法模式（Static FactoryMethod Pattern）,是通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。<br>模式中包含的角色如下：  </p>
<ul>
<li>抽象（Product）产品角色：简单工厂模式所创建的所有对象的父类，注意，这里的父类可以是接口也可以是抽象类，它负责描述所有实例所共有的公共接口</li>
<li>工厂角色（Creator）：这是简单工厂模式的核心，由它负责创建所有的类的内部逻辑。当然工厂类必须能够被外界调用，创建所需要的产品对象</li>
<li>具体产品（Concrete Product）角色：简单工厂所创建的具体实例对象，这些具体的产品往往都拥有共同的父类  </li>
</ul>
<p>简单工厂模式解决的问题是如何去实例化一个合适的对象，<strong>核心思想：有一个专门的类来负责创建实例的过程</strong> 具体来说，把产品看着是一系列的类的集合，这些类是由某个抽象类或者接口派生出来的一个对象树。而工厂类用来产生一个合适的对象来满足客户的要求。如果简单工厂模式所涉及到的具体产品之间没有共同的逻辑，那么我们就可以使用接口来扮演抽象产品的角色；如果具体产品之间有功能的逻辑或，我们就必须把这些共同的东西提取出来，放在一个抽象类中，然后让具体产品继承抽象类。为实现更好复用的目的，共同的东西总是应该抽象出来的。Java中JDBC操作数据库就是典型的简单工厂模式，通过Class.forName()来创建与数据库连接的Connection对象  </p>
</blockquote>
<p>实现方式：  </p>
<pre><code class="java"><span class="comment">/**</span>
<span class="comment"> * 产品的抽象接口</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>{

    <span class="comment">// 产品的抽象接口</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>;
}  

<span class="comment">/**</span>
<span class="comment"> * 薯条对抽象产品接口的实现</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chips</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>{
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>{
        System.out.println(<span class="string">"我需要一份薯条！"</span>);
    }
}  

<span class="comment">/**</span>
<span class="comment"> * 鸡对产品抽象接口的实现</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chicken</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>{
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>{
        System.out.println(<span class="string">"我需要一份鸡！"</span>);
    }
}

<span class="comment">/**</span>
<span class="comment"> * 工厂角色，简单工厂模式的核心</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoodFactory</span> </span>{

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Food <span class="title">getFood</span><span class="params">(String type)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>{
        <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"chicken"</span>)) {
            <span class="keyword">return</span> Chicken.class.newInstance();
        } <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"chips"</span>)) {
            <span class="keyword">return</span> Chips.class.newInstance();
        } <span class="keyword">else</span> {
            System.out.println(<span class="string">"找不到相应的实例化的类！"</span>);
            <span class="keyword">return</span> <span class="keyword">null</span>;
        }
    }
}

<span class="comment">// 客户端测试</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPattern</span> </span>{

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException </span>{

        <span class="comment">// 实例化各种食物</span>
        Food myChicken = FoodFactory.getFood(<span class="string">"Chicken"</span>);
        Food myChips = FoodFactory.getFood(<span class="string">"Chips"</span>);
        Food myEggs = FoodFactory.getFood(<span class="string">"Eggs"</span>);

        <span class="comment">// 获取食物</span>
        <span class="keyword">if</span> (myChicken != <span class="keyword">null</span>) {
            myChicken.get();
        }

        <span class="keyword">if</span> (myChips != <span class="keyword">null</span>) {
            myChips.get();
        }

        <span class="keyword">if</span> (myEggs != <span class="keyword">null</span>) {
            myEggs.get();
        }
    }
}
</code></pre>
<blockquote>
<p><strong>优点：</strong>工厂类是整个模式的关键所在。它包含必要的判断逻辑，能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。用户在使用时可以直接根据工厂类去创建所需的实例，而无需了解这些对象是如何创建以及如何组织的。有利于整个软件体系结构的优化。</p>
<p><strong>缺点：</strong>由于工厂类集中了所有实例的创建逻辑，这就直接导致一旦这个工厂出了问题，所有的客户端都会受到牵连；而且由于简单工厂模式的产品室基于一个共同的抽象类或者接口，这样一来，但产品的种类增加的时候，即有不同的产品接口或者抽象类的时候，工厂类就需要判断何时创建何种种类的产品，这就和创建何种种类产品的产品相互混淆在了一起，违背了单一职责，导致系统丧失灵活性和可维护性。而且更重要的是，<strong>简单工厂模式违背了“开放封闭原则”</strong>，就是违背了“系统对扩展开放，对修改关闭”的原则，因为当我新增加一个产品的时候必须修改工厂类，相应的工厂类就需要重新编译一遍。</p>
<p><strong>总结：</strong>简单工厂模式分离产品的创建者和消费者，有利于软件系统结构的优化；但是由于一切逻辑都集中在一个工厂类中，导致了没有很高的内聚性，同时也违背了“开放封闭原则”。另外，简单工厂模式的方法一般都是静态的，而静态工厂方法是无法让子类继承的，因此，简单工厂模式无法形成基于基类的继承树结构</p>
</blockquote>
<h2 id="工厂模式-工厂方法模式"><a href="#工厂模式-工厂方法模式" class="headerlink" title="工厂模式-工厂方法模式"></a>工厂模式-工厂方法模式</h2><blockquote>
<p>由于简单工厂模式违背了开闭原则，扩展性差。由于只有一个工厂类，当需要一个新的产品时，整个工厂类都需要修改。因此我们可以设计多个“工厂”，每个工厂只负责生产一个产品。  </p>
</blockquote>
<p>实现方法：  </p>
<pre><code class="java"><span class="comment">// 前面定义产品的接口和实现相应的类（与上面相同）</span>

<span class="comment">// 定义工厂接口</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AllFoodFactory</span> </span>{

    <span class="function"><span class="keyword">public</span> Food <span class="title">getFood</span><span class="params">()</span></span>;
}
<span class="comment">// 定义生产鸡的工厂，实现工厂接口</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChickenFactory</span> <span class="keyword">implements</span> <span class="title">AllFoodFactory</span> </span>{
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Food <span class="title">getFood</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Chicken();
    }
}
<span class="comment">// 定义生产薯条工厂，实现工厂接口</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChipsFactory</span> <span class="keyword">implements</span> <span class="title">AllFoodFactory</span> </span>{
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Food <span class="title">getFood</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Chips();
    }
}
<span class="comment">// 客户端测试</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPattern</span> </span>{

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException </span>{
        <span class="comment">/**</span>
<span class="comment">         * 工厂方法模式的客户端</span>
<span class="comment">         */</span>
        <span class="comment">// 获取食物</span>
        AllFoodFactory chickenFactory = <span class="keyword">new</span> ChickenFactory();
        Food myChicken = chickenFactory.getFood();
        myChicken.get();

        AllFoodFactory chipsFactory = <span class="keyword">new</span> ChipsFactory();
        Food myChips = chipsFactory.getFood();
        myChips.get();
    }

}
</code></pre>
<h2 id="工厂模式-抽象工厂模式"><a href="#工厂模式-抽象工厂模式" class="headerlink" title="工厂模式-抽象工厂模式"></a>工厂模式-抽象工厂模式</h2><blockquote>
<p>抽象工厂与工厂方法模式相比，这里有多个抽象产品类或者接口存在，每个抽象的类（或者接口）可以派生出多个具体的产品，生产的是系列产品，其工厂接口相对于工厂方法模式而言，是有多个方法的，用来生产不同的抽象产品。</p>
</blockquote>
<pre><code class="java"><span class="comment">// interface BigFood</span>
<span class="comment">// interface SmallFood</span>
<span class="comment">// class BigChips implements BigFood</span>
<span class="comment">// class SmallChips implements SmallFood</span>

<span class="comment">// 定义工厂接口</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AllFactory</span></span>{
    <span class="function"><span class="keyword">public</span> BigFood <span class="title">getFood</span><span class="params">()</span></span>;

    <span class="function"><span class="keyword">public</span> SmallFood <span class="title">getFood</span><span class="params">()</span></span>;
}  

<span class="comment">// 定义生产薯条的工厂，实现接口</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChipsFactory</span> <span class="keyword">implements</span> <span class="title">AllFactory</span> </span>{

    <span class="function"><span class="keyword">public</span> BigFood <span class="title">getFood</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> BigChips();
    }

    <span class="function"><span class="keyword">public</span> SmallFood <span class="title">getFood</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> SmallChips();
    }
}
</code></pre>
<p><strong>总结：</strong></p>
<blockquote>
<p>简单工厂模式，工厂类是整个模式的关键所在，包含了必要的逻辑判断，能够外界给定的信息， 决定究竟创建哪个具体类的对象。工厂方法模式 是对简单工厂方法模式的一个抽象，抽离出了一个Factory类(或者接口)，这个接口不负责具体产品的生产，而只是指定一些规范，具体的生产工作由其子类去完成。这个模式中，工厂类和产品类往往是一一对应的，完全解决了简单工厂模式中违背“开闭原则”的问题，实现了可扩展；抽象工厂模式 的特点是存在多个抽象产品类，每个抽象产品类可以派生出多个具体产品类，工厂提供多种方法，去生产“系列”产品。</p>
<p>简单工厂模式适用于工厂类需要创建的对象比较少的情况，客户只需要传入具体的参数，就可以忽略工厂的生产细节，去获取想要的对象；工厂方法模式，主要是针对单一产品结构的情景；抽象工厂模式则是针对多级产品结构(系列产品)的一种工厂模式。最后在说一下，每种模式都有自己的优点和弊端，没有最好的模式，只有最适合的模式，只要符合实际开发需求就是最好的</p>
</blockquote>
<p><strong>博客参考链接：</strong><br>1.<a href="https://blog.csdn.net/yuan_qh/article/details/99962482" target="_blank" rel="noopener">双重校验锁实现单例模式</a><br>2.<a href="https://me.csdn.net/weiwenlongll" target="_blank" rel="noopener">简单工厂模式</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/10/Search-Algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JCZhou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Striver">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/10/Search-Algorithm/" itemprop="url">查找算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-10T10:25:23+08:00">
                2019-07-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-09-14T23:33:58+08:00">
                2020-09-14
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="编辑中"><a href="#编辑中" class="headerlink" title="编辑中"></a>编辑中</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/02/Sort-Algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JCZhou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Striver">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/02/Sort-Algorithm/" itemprop="url">排序算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-02T10:25:23+08:00">
                2019-07-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-09-14T23:41:38+08:00">
                2020-09-14
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-综述"><a href="#1-综述" class="headerlink" title="1. 综述"></a>1. 综述</h2><p>  本篇博客主要讲述几种常见的排序算法，其算法思想和实现过程。<br>  常见术语：</p>
<blockquote>
<p><strong>稳定性</strong>：两个数a和b，且a = b，排序后a和b前后顺序不变，反之不稳定。<br><strong>时间复杂度</strong>：一个算法执行所耗费的时间<br><strong>空间复杂度</strong>：运行完算法所需内存的大小<br><strong>内排序</strong>：所有排序操作都在内存中进行<br><strong>外排序</strong>：数据太大，排序操作需要内存和磁盘之间数据传输完成  </p>
</blockquote>
<p>算法总结：  </p>
<table>
<thead>
<tr>
<th style="text-align:center">排序算法</th>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">最好情况</th>
<th style="text-align:center">最坏情况</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">排序方式</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">内排序</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">内排序</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">内排序</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">O(nlog2n)</td>
<td style="text-align:center">O(nlog2n)</td>
<td style="text-align:center">O(nlog2n)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">内排序</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">内排序</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">内排序</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">外排序</td>
<td style="text-align:center">稳定</td>
</tr>
</tbody>
</table>
<h2 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h2><ul>
<li><p>直接插入排序  </p>
<blockquote>
<p>插入排序的基本思想就是将无序序列插入到有序序列中。例如要将数组arr=[4,2,8,0,5,1]排序，可以将4看做是一个有序序列(图中用蓝色标出)，将[2,8,0,5,1]看做一个无序序列。无序序列中2比4小，于是将2插入到4的左边，此时有序序列变成了[2,4]，无序序列变成了[8,0,5,1]。无序序列中8比4大，于是将8插入到4的右边，有序序列变成了[2,4,8],无序序列变成了[0,5,1]。以此类推，最终数组按照从小到大排序。该算法的时间复杂度为O(n^2)  </p>
</blockquote>
<p>  <img src="/images/Sort_Algorithm_01.png" alt="直接插入排序"></p>
<p>  代码实现</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertionSortI</span><span class="params">(<span class="keyword">int</span> []arr, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j-- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[j-<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>希尔排序</p>
<blockquote>
<p>希尔排序实在直接插入排序后的改进版本，也称为缩小增量排序，先将待排序列分为若干子序列，进行直接插入排序，最后等整个序列“基本有序”，再进行一次直接插入排序。其基本思想是将组内元素按一定增量分组，每组按直接插入排序算法排序；随着增量逐渐减少，每组包含的元素越来越多，当增量减为1时，恰好分为一组，再进行一次直接插入排序，完成算法。其中第一次增量为<code>gap=length/2</code>,增量以<code>gap/2</code>减少至1（length为待排序列的长度）  </p>
</blockquote>
<p> 代码实现  </p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> []arr, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp, gap = length/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(gap &gt; <span class="number">0</span>) <span class="comment">//外循环，表示进行几轮</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//每轮中各组交替进行插入排序</span></span><br><span class="line">            temp = gap;</span><br><span class="line">            <span class="keyword">int</span> preIndex = i - gap;</span><br><span class="line">            <span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; temp)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[preIndex + gap] = arr[preIndex];</span><br><span class="line">                preIndex -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[preIndex + gap] = temp; <span class="comment">//插入合适的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h2><ul>
<li><p>简单选择排序</p>
<blockquote>
<p>基本思想：每一趟在待排序列的<code>n-i+1(i=1、2...n-1)</code>的记录中选取关键字最小（大）的记录作为有序序列的第i个记录。算法的时间复杂度为O(n^2)  </p>
</blockquote>
<p> 代码实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> []arr, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[minIndex])</span><br><span class="line">            &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minindex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>堆排序</p>
<blockquote>
<p>堆排序是用数据结构–堆，进行排序。可以将堆看做一个完全二叉树，并且当每个结点的值都大于等于其左右孩子，这称为大顶堆；若小于等于，则称为小顶堆。堆排序是先将序列构造成一个大顶堆（小顶堆），则序列的最大值（最小值）就是堆顶元素，也是根结点。之后将根结点与末尾元素进行交换，此时末尾元素就是最大值（最小值），再将剩下的n-1个元素建堆，得到次大值（次小值），依次类推得到有序序列。堆排序的过程包括 <strong>建堆过程</strong> 和 <strong>堆调整过程</strong>,同时也使用了递归思想。</p>
</blockquote>
<p>代码实现</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//建堆过程函数，其中递归调用了堆调整的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> []arr, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = length / <span class="number">2</span> -<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//第一次建堆过程,从最后一个非叶结点开始进行调整</span></span><br><span class="line">        HeapAdjust(arr, i, length)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = length - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">       arr[<span class="number">0</span>] = arr[j];</span><br><span class="line">       arr[j] = temp;</span><br><span class="line">       HeapAdjust(arr, <span class="number">0</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆调整方法，调整数组arr的第i个结点，新堆长度为length</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> []arr, <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = i; <span class="comment">//堆初始下标为0</span></span><br><span class="line">    <span class="keyword">int</span> lchild = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rchild = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(lchild &lt; length &amp;&amp; arr[lchild] &gt; arr[max])</span><br><span class="line">    &#123;</span><br><span class="line">        max = lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rchild &lt; length &amp;&amp; arr[rchild] &gt; arr[max])</span><br><span class="line">    &#123;</span><br><span class="line">        max = rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断该位置是否调整，则进行位置调换并向下调整</span></span><br><span class="line">    <span class="keyword">if</span>(max != i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[max];</span><br><span class="line">        arr[max] = temp;</span><br><span class="line">        HeapAdjust(arr, max, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-交换排序"><a href="#4-交换排序" class="headerlink" title="4. 交换排序"></a>4. 交换排序</h2><ul>
<li><p>冒泡排序</p>
<blockquote>
<p>最简单的一种排序算法，首先从待排序列的第一个元素开始到最后一个元素为止，对相邻的两个元素进行比较，若左边元素大于（小于）右边的元素，则交换位置。一轮过后，则最后一个位置的元素为最大值（最小值）。接着对剩下的n-1个元素进行冒泡排序，直到达到有序序列。  </p>
</blockquote>
<p>代码实现</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> []arr, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length &lt;= <span class="number">1</span>)</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>快速排序</p>
<blockquote>
<p>快速排序使用 <strong>分治法</strong> ，把一个串分为两个子串。基本思想：挑选一个元素作为“基准”（一般选择第一个元素），经过一趟排序后，将小于基准的元素放在基准元素前面，大于的放在基准元素后面，以基准值为分界线，分为两个子序列，同时基准值位置为最终位置。接着对两个子序列分别进行递归算法调用快速排序。 具体做法：设置两个指针low、high分别指向待排序列的开头和末尾，记录下基准值（待排序列的第一个元素），然后先从high指针开始向前走，找到小于基准值的元素并停下，之后low指针向后走，找到大于基准值的元素并停下，在两个指针位置没有重合的情况下，并且都停下后，则交换两个指针所指的元素，继续往前往后走，当两个指针重合后，则交换基准位置和指针位置，第一轮结束，分为以基准值为分界线的两个子序列。递归继续</p>
</blockquote>
<p>代码实现</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> []arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = high;</span><br><span class="line">    <span class="keyword">if</span>(low &gt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//基准值</span></span><br><span class="line">    <span class="keyword">int</span> standard = arr[low];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(standard &lt; arr[j] &amp;&amp; i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(standard &gt; arr[i] &amp;&amp; i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调整到基准值最终的位置</span></span><br><span class="line">    arr[low] = arr[i];</span><br><span class="line">    arr[i] = standard;</span><br><span class="line">    <span class="comment">//递归调用快速排序子序列</span></span><br><span class="line">    QuickSort(arr, low, j - <span class="number">1</span>);</span><br><span class="line">    QuickSort(arr, j +<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h2><ul>
<li><p>二路归并排序</p>
<blockquote>
<p>归并是指将两个或两个以上的 <strong>有序序列</strong> 组合成一个新的有序序列。初始序列有n个元素，可以看成有n个有序的子序列，每个子序列的长度为1，再两两归并，得到n/2个长度为2有序子序列，再两两归并，直到得到一个n长度的有序序列，该方法为2路归并排序。  <strong>具体的方法</strong>：先递归拆分到只包含单个元素的子序列，再两两合并。分治法的思想，是一种稳定的排序方法。</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> [] MergeSort(<span class="keyword">int</span> [] arr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = arr.length / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//imports java.util.Arrays</span></span><br><span class="line">    <span class="keyword">int</span> [] left = Arrays.copyOfRange(arr, <span class="number">0</span> ,mid);</span><br><span class="line">    <span class="keyword">int</span> [] right = Arrays.copyOfRange(arr, mid, arr.length);</span><br><span class="line">    <span class="keyword">return</span> Merge(MergeSort(left), MergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将两个有序子序列合并排序成一个有序序列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> [] Merge(<span class="keyword">int</span> [] left, <span class="keyword">int</span> [] right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> [] result = <span class="keyword">new</span> <span class="keyword">int</span> [left.length + right.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>; index &lt; result.length; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当左边有序子序列都插入结果序列后</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= left.length)</span><br><span class="line">        &#123;</span><br><span class="line">            result[index] = right[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当右边有序子序列都插入结果序列后</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j &gt;= right.length)</span><br><span class="line">        &#123;</span><br><span class="line">            result[index] = left[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//由于左右两个子序列都是有序序列，因此从第一个元素开始比较</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left[i] &gt; right[j])</span><br><span class="line">        &#123;</span><br><span class="line">            result[index] = right[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result[index] = left[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>博客参考链接：<br>1.<a href="https://blog.csdn.net/hellozhxy/article/details/79911867" target="_blank" rel="noopener">十大经典排序总结</a><br>2.<a href="https://blog.csdn.net/liang_gu/article/details/80627548#commentBox" target="_blank" rel="noopener">常见的7种排序算法</a><br>3.<a href="https://blog.csdn.net/shujuelin/article/details/82423852" target="_blank" rel="noopener">快速排序</a>  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/20/Hexo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JCZhou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Striver">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/20/Hexo/" itemprop="url">Hexo usage</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-20T14:05:14+08:00">
                2019-06-20
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-07-08T10:24:02+08:00">
                2019-07-08
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>本篇文章主要讲述使用Hexo写博客的一些技巧和注意事项</p>
<hr>
<h2 id="添加分类和标签"><a href="#添加分类和标签" class="headerlink" title="添加分类和标签"></a>添加分类和标签</h2><ul>
<li>分类  <blockquote>
<p>命令行进入博客（hexo）所在的文件夹，执行<code>hexo new page categories</code>,成功后自动生成source/categories/index.md，再修改index.md文件。再给文章添加相应的<code>categories</code>属性。  </p>
</blockquote>
</li>
<li>标签<blockquote>
<p>同理，执行<code>hexo new page tags</code>,再修改对应的index.md文件。最后再给文章添加<code>tags</code>属性  </p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="博客插入图片"><a href="#博客插入图片" class="headerlink" title="博客插入图片"></a>博客插入图片</h2><ol>
<li><p>使用绝对路径<br>将所有项目的图片都统一放在`source/images文件夹中，访问显示图片可用绝对地址，图片的地址如 <strong>/images/image.jpg</strong> ，这样图片可在首页和文章中都可访问到</p>
</li>
<li><p>使用相对路径<br>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中，通过配置博客根目录下<code>_config.yml</code>来生成。将其中的配置项<code>post_asset_folder: true</code>后，执行<code>hexo new post_name</code>，在source/_posts中生成文章post_name.md和同名文件夹post_name。我们将图片放在post_name文件夹中，通过image.jpg可直接引用。但是该方法只能在文章中显示图片，为了能在首页显示图片，可以用以下方法：<br><img src="/images/Hexo_001.png" alt="显示方法"></p>
</li>
<li>使用图床</li>
</ol>
<h2 id="发表博客的步骤"><a href="#发表博客的步骤" class="headerlink" title="发表博客的步骤"></a>发表博客的步骤</h2><blockquote>
<p>首先命令行进入hexo文件夹下<code>hexo new file_name</code>，这样在source/_post文件夹下多了.md文件，或者直接将写好的markdown文件放入对应的文件夹，注意需要额外添加开头信息（Front-matter）。当编辑好后，可以先通过命令<code>hexo s -debug</code>在本地浏览器的localhost：4000预览博文效果。最后<code>hexo g,hexo d</code>生成和部署</p>
</blockquote>
<hr>
<h2 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h2><p><img src="/images/Hexo_002.png" alt="表格语法格式"><br><img src="/images/Hexo_003.jpeg" alt="表格对齐方式"><br><strong>表格部分需要和正文部分空1行以上，否则表格不显示</strong></p>
<h2 id="Markdown语法进阶"><a href="#Markdown语法进阶" class="headerlink" title="Markdown语法进阶"></a>Markdown语法进阶</h2><h2 id="Hexo-Github博客建站指南"><a href="#Hexo-Github博客建站指南" class="headerlink" title="Hexo+Github博客建站指南"></a>Hexo+Github博客建站指南</h2><p>这是博客建站的参考链接<a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">知乎</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/07/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JCZhou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Striver">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/07/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-07T10:54:01+08:00">
                2019-05-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-05-07T10:54:01+08:00">
                2019-05-07
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">JCZhou</p>
              <p class="site-description motion-element" itemprop="description">每天学习一点点</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JCZhou</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
